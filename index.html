<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de Topologia de Rede</title>
    
    <!-- Leaflet.js (CSS) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        /* Define a altura do mapa */
        #map { height: 60vh; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        body { font-family: 'Inter', sans-serif; }
        
        /* Estilos das Abas */
        .tab-button {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border-radius: 0.375rem 0.375rem 0 0;
            font-weight: 500;
            background-color: #f3f4f6; /* bg-gray-100 */
            color: #4b5563; /* text-gray-600 */
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }
        .tab-button.active {
            background-color: #ffffff; /* bg-white */
            color: #1d4ed8; /* text-blue-700 */
            border-bottom: 2px solid #1d4ed8; /* border-blue-700 */
        }
        .tab-content {
            display: none;
            background-color: #ffffff;
            border-radius: 0 0 0.5rem 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        .tab-content.active {
            display: block;
        }

        /* Estilo para a tabela com "scroll" */
        .table-container {
            max-height: 60vh;
            overflow-y: auto;
        }
        /* Fixar o cabeçalho da tabela */
        .table-container thead th {
            position: sticky;
            top: 0;
            background-color: #f9fafb; /* bg-gray-50 */
            z-index: 10;
        }

        /* Remove setas do input[type=number] */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }

        /* Pop-up do Leaflet personalizado */
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
        }
        .leaflet-popup-content {
            font-size: 13px;
            line-height: 1.6;
        }
        .popup-title {
            font-weight: 700;
            font-size: 1.1rem;
            color: #1d4ed8;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-bottom: 8px;
        }
        .popup-section {
            font-weight: 600;
            color: #374151; /* text-gray-700 */
            margin-top: 10px;
        }
        
        /* Estilo para os rótulos dos setores no mapa */
        .sector-label {
            background: transparent;
            border: 0;
            box-shadow: none;
            color: #000000;
            font-weight: bold;
            font-size: 11px;
            /* Sombra para legibilidade em cima de outras cores */
            text-shadow: 1px 1px 2px #fff, -1px -1px 2px #fff, 1px -1px 2px #fff, -1px 1px 2px #fff;
        }

        /* NOVO: Estilos para controles customizados do Leaflet */
        .leaflet-control-resetzoom a,
        .leaflet-control-northarrow div {
            width: 30px; /* Padrão do Leaflet */
            height: 30px; /* Padrão do Leaflet */
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            text-decoration: none;
            color: #000;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }
        .leaflet-control-resetzoom a {
            cursor: pointer;
        }
        .leaflet-control-northarrow div {
            cursor: default;
            padding-top: 2px; /* Ajuste fino para o SVG */
        }
        /* Garante que os novos controles se pareçam com os botões de zoom */
        .leaflet-bar a, .leaflet-bar div {
             border-bottom: 1px solid #ccc;
        }
        .leaflet-bar a:last-child, .leaflet-bar div:last-child {
             border-bottom: none;
        }

    </style>
</head>

<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-blue-700">Visualizador de Topologia de Rede</h1>
            <p class="text-md text-gray-600 mt-1">Carregue os arquivos CSV para gerar o mapa e as tabelas.</p>
        </header>

        <!-- Seção de Upload -->
        <div class="bg-white p-6 rounded-lg shadow-md mb-6">
            <!-- Grid atualizado para 5 colunas -->
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">
                
                <!-- File 1: Rádio -->
                <div class="md:col-span-1">
                    <label for="csvRadio" class="block text-sm font-medium text-gray-700 mb-1">1. Rádio (Delimitador: ;)</label>
                    <input type="file" id="csvRadio" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors">
                </div>
                
                <!-- File 2: Switch -->
                <div class="md:col-span-1">
                    <label for="csvSwitch" class="block text-sm font-medium text-gray-700 mb-1">2. Switch (Delimitador: ;)</label>
                    <input type="file" id="csvSwitch" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors">
                </div>
                
                <!-- File 3: Seriais -->
                <div class="md:col-span-1">
                    <label for="csvSeriais" class="block text-sm font-medium text-gray-700 mb-1">3. Seriais (Delimitador: ;)</label>
                    <input type="file" id="csvSeriais" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors">
                </div>

                <!-- REMOVIDO: File 4: Setor -->
                
                <!-- Seletor de Raio -->
                <div class="md:col-span-1">
                    <label for="sectorRadius" class="block text-sm font-medium text-gray-700 mb-1">Raio Setor (m)</label>
                    <select id="sectorRadius" class="block w-full text-sm text-gray-900 border border-gray-300 rounded-md py-2 px-3 focus:ring-blue-500 focus:border-blue-500 transition-colors">
                        <option value="70" selected>70m</option>
                        <option value="300">300m</option>
                    </select>
                </div>
                
                <!-- Botão de Geração (col-span-1) -->
                <button id="generateButton" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md font-semibold hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors shadow-sm md:col-span-1">
                    Gerar Topologia
                </button>
            </div>
            
            <!-- Mensagem de Status/Erro -->
            <div id="messageBox" class="mt-4 p-3 rounded-md text-sm text-center hidden"></div>
        </div>

        <!-- Container do Mapa -->
        <div id="mapContainer" class="mb-6">
            <div id="map"></div>
        </div>
        
        <!-- Container das Abas e Tabelas -->
        <div id="tablesContainer" class="hidden">
            <!-- Botões das Abas -->
            <div class="flex border-b border-gray-300">
                <button class="tab-button active" onclick="openTab(event, 'linksTab')">Lista de Links</button>
                <button class="tab-button" onclick="openTab(event, 'inventoryTab')">Inventário de Nós</button>
                <!-- REMOVIDO: Botão da Aba Azimute -->
            </div>
            
            <!-- Conteúdo da Aba 1: Lista de Links -->
            <div id="linksTab" class="tab-content active">
                <div class="table-container">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <!-- NOVO: Coluna Cluster -->
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Cluster</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">CEN A</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">CEN B</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Produto A</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Produto B</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">TDD-POL</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Azimute A (deg)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Azimute B (deg)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Sect-In-Device</th>
                                <!-- NOVAS COLUNAS -->
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">TX Power A/B (dBm)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">RSSI (dBm) A/B</th>
                                <!-- FIM DAS NOVAS COLUNAS -->
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Freq. A (MHz)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Freq. B (MHz)</th>
                                <!-- NOVO: Coluna Setor 1 (Base) -->
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Setor 1 (Azimute)</th>
                            </tr>
                        </thead>
                        <tbody id="linkListBody" class="bg-white divide-y divide-gray-200">
                            <!-- Linhas inseridas via JS -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- Conteúdo da Aba 2: Inventário de Nós -->
            <div id="inventoryTab" class="tab-content">
                <div class="table-container">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <!-- NOVO: Coluna Cluster -->
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Cluster(s)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">CEN</th>
                                <!-- ATUALIZADO: Coluna Node ID -->
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Node ID</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Produtos</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">IPs</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">VLANs</th>
                                <!-- NOVO: Coluna Part Number -->
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Part Number</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Seriais</th>
                            </tr>
                        </thead>
                        <tbody id="nodeInventoryBody" class="bg-white divide-y divide-gray-200">
                            <!-- Linhas inseridas via JS -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- REMOVIDO: Conteúdo da Aba Azimute -->

        </div>

    </div> <!-- Fim do container -->

    <!--
    Scripts movidos para o final do <body> para garantir a ordem de carregamento
    1. Leaflet JS
    2. Leaflet Semicircle Plugin (depende do Leaflet)
    3. Tailwind CSS
    -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-semicircle@2.0.4/Semicircle.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Script Principal da Aplicação -->
    <script>
        // Variável global para o mapa
        let map;
        // NOVO: Referência ao controle de camadas
        let layerControl; 
        
        // Objeto para armazenar as camadas do mapa (para poder limpar)
        const mapLayers = {
            markers: null,
            lines: null,
            // Novas camadas, uma para cada setor
            sectors1: null,
            sectors2: null,
            sectors3: null,
            sectors4: null
        };
        // NOVO: Objeto para camadas de cluster dinâmicas
        let clusterLayers = {}; 

        // Dados globais processados
        // ATUALIZAÇÃO: 'nodes' agora é indexado pelo NODE ID (não pelo CEN)
        let nodes = {};
        let links = [];
        let serialMap = new Map(); // Mapa de IP -> { serial, partNumber }
        // REMOVIDO: independentSectors = []; 
        // REMOVIDO: sectorAzimuthMap = new Map(); 
        let subnetVlanMap = new Map(); // NOVO: Mapa Mestre de Sub-rede -> VLAN

        /**
         * Inicializa o mapa Leaflet assim que a página carrega.
         */
        function initMap() {
            if (map) return; // Não inicializa duas vezes
            
            try {
                map = L.map('map').setView([-14.2350, -51.9253], 5); // Centro do Brasil (Zoom inicial 5)
                const baseTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                
                mapLayers.markers = L.layerGroup().addTo(map);
                mapLayers.lines = L.layerGroup().addTo(map);
                
                // Cria as 4 camadas de setores
                mapLayers.sectors1 = L.layerGroup().addTo(map);
                mapLayers.sectors2 = L.layerGroup().addTo(map);
                mapLayers.sectors3 = L.layerGroup().addTo(map);
                mapLayers.sectors4 = L.layerGroup().addTo(map);


                // Adiciona controle de camadas (toggle)
                const baseMaps = {
                    "OpenStreetMap": baseTileLayer
                };
                const overlayMaps = {
                    "Links": mapLayers.lines,
                    "Nós (Markers)": mapLayers.markers,
                    // Novas camadas de setor
                    "Setor 1 (MH-N)": mapLayers.sectors1,
                    "Setor 2 (MH-N)": mapLayers.sectors2,
                    "Setor 3 (MH-N)": mapLayers.sectors3,
                    "Setor 4 (MH-N)": mapLayers.sectors4
                    // Camadas de cluster são adicionadas dinamicamente
                };
                
                // Salva a referência do controle de camadas
                layerControl = L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);

                // --- NOVO: Adiciona Controles de Reset e Norte ---
                
                // 1. Botão de Reset Zoom
                const ResetZoomControl = L.Control.extend({
                    options: {
                        position: 'topleft'
                    },
                    onAdd: function (map) {
                        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-resetzoom');
                        const link = L.DomUtil.create('a', '', container);
                        link.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>`;
                        link.href = '#';
                        link.title = 'Resetar Zoom';

                        L.DomEvent.on(link, 'click', L.DomEvent.stop);
                        L.DomEvent.on(link, 'click', () => {
                            map.setView([-14.2350, -51.9253], 5);
                        });

                        return container;
                    }
                });
                map.addControl(new ResetZoomControl());

                // 2. Seta do Norte
                const NorthArrowControl = L.Control.extend({
                    options: {
                        position: 'topleft'
                    },
                    onAdd: function (map) {
                        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-northarrow');
                        container.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2.5"><path d="M12 19V5M12 5L8 9M12 5L16 9"></path><text x="12" y="4" font-size="8" fill="#333" font-weight="600" text-anchor="middle">N</text></svg>`;
                        container.title = 'Norte';
                        return container;
                    }
                });
                map.addControl(new NorthArrowControl());
                
                // --- Fim dos Novos Controles ---


                // Adiciona legenda de cores (MH-N)
                const legend = L.control({ position: 'bottomright' });
                legend.onAdd = function (map) {
                    const div = L.DomUtil.create('div', 'info legend');
                    const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
                    const labels = ['Setor 1', 'Setor 2', 'Setor 3', 'Setor 4'];
                    
                    let legendHtml = '<div style="background:white; padding: 10px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.2);">';
                    legendHtml += '<strong style="display:block; margin-bottom: 5px;">Legenda (MH-N)</strong>';
                    
                    const iStyle = 'width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.7;';

                    for (let i = 0; i < labels.length; i++) {
                        legendHtml +=
                            `<div><i style="${iStyle} background:${colors[i]}"></i> ${labels[i]}</div>`;
                    }
                    legendHtml += '</div>';
                    div.innerHTML = legendHtml;
                    return div;
                };
                legend.addTo(map);


            } catch (e) {
                console.error("Erro ao inicializar o mapa Leaflet:", e);
                showMessage("Erro fatal ao carregar o mapa. Verifique a conexão com a internet.", true);
            }
        }

        /**
         * Remove o BOM (Byte Order Mark) invisível do início do texto do CSV.
         */
        function cleanCSVText(text) {
            if (text.charCodeAt(0) === 0xFEFF) {
                return text.substring(1);
            }
            return text;
        }
        
        // REVERSÃO: parseCoord (simples) - Lógica da V1.6.0 3.html
        const parseCoordSimple = (val) => {
            if (!val) return NaN;
            // Tenta formato (combinado, com vírgula ou ponto)
            let coord = parseFloat(val.replace(',', '.'));
            if (!isNaN(coord)) {
                return coord;
            }
            return NaN; // Falha
        };
        
        // REVERSÃO: parseCoord (complexo) - Lógica da V1.6.0 3.html
        // Tenta formato combinado (ex: "-22,911099")
        // Se falhar (NaN), tenta formato dividido (ex: "-22" e "911099")
        const parseCoordComplex = (valCombined, valPart1, valPart2) => {
            // Tenta formato 1 (combinado, com vírgula ou ponto)
            let coord = parseFloat(valCombined?.replace(',', '.'));
            if (!isNaN(coord)) {
                return coord;
            }
            
            // Tenta formato 2 (dividido)
            const partA = valPart1?.trim();
            const partB = valPart2?.trim();
            if (partA && partB) {
                coord = parseFloat(`${partA}.${partB}`);
                if (!isNaN(coord)) {
                    return coord;
                }
            }
            return NaN; // Falha
        };


        /**
         * Converte texto CSV em um array de objetos.
         * A primeira linha é usada como cabeçalho.
         */
        async function parseCSV(file, delimiter = ';') {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const csvText = event.target.result;
                        const cleanedText = cleanCSVText(csvText);
                        
                        // Divide por quebras de linha (incluindo \r\n e \n)
                        const lines = cleanedText.split(/\r?\n/).filter(line => line.trim() !== '');

                        if (lines.length === 0) {
                            // Arquivo está completamente vazio
                             reject(new Error("Arquivo CSV está vazio."));
                             return;
                        }

                        const headers = lines[0].split(delimiter).map(h => h.trim());
                        
                        if (headers.length === 0 || (headers.length === 1 && headers[0] === '')) {
                            reject(new Error("Cabeçalho do CSV não encontrado ou mal formatado."));
                            return;
                        }

                        // CORREÇÃO: Permite arquivos que tenham apenas cabeçalho (0 linhas de dados)
                        const rows = lines.slice(1).map(line => {
                            const values = line.split(delimiter);
                            return headers.reduce((obj, header, index) => {
                                obj[header] = values[index] ? values[index].trim() : '';
                                return obj;
                            }, {});
                        });
                        
                        resolve({ headers, rows });

                    } catch (e) {
                         reject(new Error(`Erro ao processar CSV: ${e.message}`));
                    }
                };
                reader.onerror = () => {
                     reject(new Error("Não foi possível ler o arquivo."));
                };
                reader.readAsText(file);
            });
        }
        
        // NOVO: Função auxiliar para VLAN
        const getSubnet = (ip) => {
            if (!ip || ip === '-') return null;
            return ip.split('.').slice(0, 3).join('.');
        }


        /**
         * Função principal para ler e processar os arquivos.
         */
        async function handleFiles() {
            const fileRadio = document.getElementById('csvRadio').files[0];
            const fileSwitch = document.getElementById('csvSwitch').files[0];
            const fileSeriais = document.getElementById('csvSeriais').files[0];
            // REMOVIDO: const fileSetor

            // NOVO: Lê o valor do raio selecionado
            const selectedRadius = parseInt(document.getElementById('sectorRadius').value, 10);

            // ATUALIZADO: Volta para 3 arquivos (Seriais é opcional)
            if (!fileRadio || !fileSwitch) { 
                showMessage("Por favor, selecione pelo menos os arquivos Rádio e Switch.", true);
                return;
            }

            // Reseta os dados globais
            nodes = {};
            links = [];
            serialMap.clear();
            subnetVlanMap.clear(); // NOVO (VLAN)
            
            // Limpa visualizações anteriores
            clearVisuals();
            showMessage("Processando arquivos...", false);
            
            try {
                // 1. Lê o arquivo de Seriais (IP -> Serial) - OPCIONAL
                if (fileSeriais) {
                    try {
                        const serialData = await parseCSV(fileSeriais, ';');
                        serialData.rows.forEach(row => {
                            const ip = row['IP']?.trim();
                            const serial = row['Serial Number']?.trim();
                            // NOVO: Lê o Part Number
                            const partNumber = row['Part Number']?.trim(); 
                            
                            // ATUALIZAÇÃO: Armazena um objeto no map
                            if (ip && (serial || partNumber)) {
                                serialMap.set(ip, { 
                                    serial: serial || '-', 
                                    partNumber: partNumber || '-' 
                                });
                            }
                        });
                    } catch (e) {
                         console.warn("Arquivo de seriais não pôde ser processado (talvez esteja vazio), continuando...");
                    }
                }
                
                // console.log(`Arquivo de Seriais processado. ${serialMap.size} IPs mapeados.`);

                // 2. Lê o arquivo de Switch (CEN -> Info Switch)
                // ATUALIZAÇÃO: Processa o Switch primeiro, indexado por Node ID
                const switchData = await parseCSV(fileSwitch, ';');
                
                switchData.rows.forEach(row => {
                    const cen = row['CEN']?.trim();
                    const nodeID = row['Node ID']?.trim();
                    if (!nodeID) return; // Pula linha se não tiver Node ID
                    
                    const produto = row['DESCRIÇÃO']?.trim() || row['Product']?.trim() || '-';
                    const ipRaw = row['IP/Mascara']?.trim() || row['IP address']?.trim() || '-';
                    const ip = ipRaw.split('/')[0]; 
                    const vlan = row['VLAN']?.trim() || '-';
                    
                    // Cria a entrada do nó (baseada no Node ID)
                    if (!nodes[nodeID]) {
                         nodes[nodeID] = createEmptyNode(nodeID);
                    }
                    
                    // Adiciona dados do Switch
                    nodes[nodeID].cen = cen; // CEN (localização)
                    nodes[nodeID].switchProduct = produto;
                    nodes[nodeID].switchIP = ip;
                    nodes[nodeID].switchVLAN = vlan;
                    // (Lat/Lon e Clusters virão do arquivo de Rádio)

                    // NOVO (VLAN): Popula o mapa mestre de Sub-rede -> VLAN
                    const subnet = getSubnet(ip);
                    if (subnet && vlan !== '-') {
                        subnetVlanMap.set(subnet, vlan);
                    }
                });
                // console.log(`Arquivo de Switch processado. ${Object.keys(nodes).length} nós (switches) criados.`);

                
                // 3. Lê o arquivo de Rádio (Arquivo principal)
                const radioData = await parseCSV(fileRadio, ';');
                
                if (radioData.rows.length === 0) {
                    throw new Error("Arquivo de Rádio não contém dados.");
                }

                // Passa o tempSwitchMap para a função
                processRadioData(radioData.rows);

                // 5. Renderiza tudo
                renderMap(selectedRadius); // Passa o raio selecionado
                renderTables();

                document.getElementById('tablesContainer').classList.remove('hidden');
                showMessage(`Topologia gerada com sucesso! ${Object.keys(nodes).length} nós e ${links.length} links encontrados.`, false);

            } catch (error) {
                console.error("Erro no processamento dos arquivos:", error);
                showMessage(`Erro no processamento dos arquivos: ${error.message}`, true);
            }
        }
        
        /**
         * NOVO: Função helper para criar um nó (baseado em Node ID)
         */
        function createEmptyNode(nodeID) {
             return {
                nodeID: nodeID,
                cen: 'N/A', // Será preenchido pelo Switch ou Rádio
                lat: null, // Será preenchido pelo Rádio
                lon: null, // Será preenchido pelo Rádio
                
                // ATUALIZAÇÃO: Rádios agora são um array de objetos
                radios: [], // [{ product, ip, vlan, freq, tddPol, sectorNum, azimuth }]
                
                switchProduct: '-',
                switchIP: '-',
                switchVLAN: '-',
                
                clusters: new Set(), // Armazena clusters do nó
                
                // Armazena (Setor -> Azimute REAL)
                // (Usado para desenhar os setores MH-N)
                sectors: new Map(), 
                calculatedBaseAzimuth: undefined // Armazena o Azimute Base CALCULADO
            };
        }

        /**
         * Processa os dados do arquivo de Rádio.
         */
        function processRadioData(rows) { // Não precisa mais do switchMap
            
            // parseCoord foi movido para o escopo global

            // NOVO: Função auxiliar para a regra do Setor (+1)
            const parseSectorRule = (val) => {
                const trimmedVal = val?.trim();
                // NOVO: Converte para número
                const num = parseInt(trimmedVal, 10);

                // Verifica se é um número válido (incluindo 0)
                if (!isNaN(num)) {
                    return (num + 1).toString(); // Soma +1
                }
                
                // Se não for um número (ex: "-", "P2P", vazio), retorna o original
                return trimmedVal || '-';
            };

            for (const row of rows) {
                const cenA = row['CEN A']?.trim();
                let cenB = row['CEN B']?.trim(); // MUDANÇA: const -> let
                const nodeIDA = row['Node ID A']?.trim();
                const nodeIDB = row['Node ID B']?.trim();

                // MUDANÇA: Lê o produto ANTES da verificação de nulos
                const productRaw = row['Product']?.trim() || '-';

                // MUDANÇA: Regra de negócio para MH-T280
                if (productRaw.includes("MH-T280")) {
                    cenB = cenA; // Força o CEN B a ser igual ao CEN A
                }

                // Pula se não tiver Node IDs ou CENs (agora cenB está preenchido, se necessário)
                if (!cenA || !cenB || !nodeIDA || !nodeIDB) continue;

                // --- REVERSÃO: Coordenadas (Lógica Híbrida da V1.6.0 3.html) ---
                // Tenta primeiro o formato "simples" (PREFEITURA-5 / CONSOLIDADO)
                let latA = parseCoordSimple(row['Node Lat A']);
                let lonA = parseCoordSimple(row['Node Lon A']);
                let latB = parseCoordSimple(row['Node Lat B']);
                let lonB = parseCoordSimple(row['Node Lon B']);

                // Se falhar (NaN), tenta o formato "complexo" (PREFEITURA-2)
                if (isNaN(latA) || isNaN(lonA) || isNaN(latB) || isNaN(lonB)) {
                    latA = parseCoordComplex(row['Node Lat A'], row['Node Lat A'], row['Node Lon A']);
                    lonA = parseCoordComplex(row['Node Lon A'], row['AltitudeMode_A'], row['Height_A (m (feet))']);
                    latB = parseCoordComplex(row['Node Lat B'], row['Node Lat B'], row['Node Lon B']);
                    lonB = parseCoordComplex(row['Node Lon B'], row['AltitudeMode_B'], row['Height_B (m (feet))']);
                }
                
                // Se qualquer coordenada falhar *depois* das duas tentativas, pula este link
                if (isNaN(latA) || isNaN(lonA) || isNaN(latB) || isNaN(lonB)) {
                    // console.warn(`Coordenadas inválidas para o link ${cenA}-${cenB}. Pulando.`);
                    continue;
                }
                
                // NOVO: Lê o CLUSTER
                const cluster = row['CLUSTER']?.trim() || 'Sem Cluster';

                // NOVO: Se o cluster é novo, cria uma camada para ele
                if (cluster !== 'Sem Cluster' && !clusterLayers[cluster]) {
                    const newLayer = L.layerGroup().addTo(map); // Adiciona ao mapa
                    clusterLayers[cluster] = newLayer;
                    layerControl.addOverlay(newLayer, cluster); // Adiciona ao controle de camadas
                }

                // --- Outros Dados do Link ---
                // MUDANÇA: productRaw já foi lido acima
                // const productRaw = row['Product']?.trim() || '-'; 
                let produtoA, produtoB;
                let produtoBaseA, produtoBaseB; // Para o Inventário

                // CORREÇÃO: Usa o separador exato " - " (com espaços)
                if (productRaw.includes(" - ")) {
                    const parts = productRaw.split(" - ");
                    produtoA = parts[0]?.trim() || '-';
                    produtoB = parts[1]?.trim() || '-';
                } else {
                    // ATUALIZAÇÃO: Se não houver " - ", repete o nome e adiciona (R) ao Produto B
                    produtoA = productRaw;
                    produtoB = `${productRaw} (R)`;
                }

                // O nome do produto para o inventário (produtoBase) deve ser o mesmo
                produtoBaseA = produtoA;
                produtoBaseB = produtoB; // Agora produtoB carrega o nome com (R)
                
                const ipA = row['IP address A']?.trim() || '-';
                const ipB = row['IP address B']?.trim() || '-';
                const freqA = row['TX freq (MHz) A']?.trim() || '-';
                const freqB = row['TX freq (MHz) B']?.trim() || '-';
                const tddPol = row['TDD-pol']?.trim() || '-';
                
                // --- NOVAS COLUNAS (PARA A TABELA DE LINKS) ---
                const azimuthA = row['Antenna Azimuth (deg) A']?.trim() || '-';
                const azimuthB = row['Antenna Azimuth (deg) B']?.trim() || '-';
                // APLICA A REGRA (+1)
                const sectInDevice = parseSectorRule(row['Sect-In-Device index']);
                
                // NOVO: Lê TX Power e RSSI
                const txPower = row['TX Power A/B (dBm)']?.trim() || '-';
                const rssi = row['RSSI (dBm) A/B']?.trim() || '-';
                
                // --- NOVO: Cálculo do Azimute do Setor 1 (Baseado na regra de rede) ---
                let setor1CalculatedAz = '-';
                const sectorNumN = parseInt(sectInDevice, 10); // N (já com +1)
                const azimuthNumAz = parseFloat(azimuthA.replace(',', '.')); // Az
                
                // Verifica se é um rádio MH-N e se os dados são numéricos
                if (produtoBaseA.startsWith("MH-N") && !isNaN(sectorNumN) && !isNaN(azimuthNumAz)) {
                    // Fórmula: Az(1) = (Az(N) - (N - 1) * 90)
                    const calculatedAz = azimuthNumAz - ((sectorNumN - 1) * 90);
                    
                    // Normaliza o ângulo (para lidar com valores negativos, ex: 70 - 90 = -20)
                    const normalizedAz = (calculatedAz % 360 + 360) % 360;
                    
                    setor1CalculatedAz = `${normalizedAz.toFixed(1)}°`;
                }
                // --- FIM DO CÁLCULO ---
                
                // --- Adiciona/Atualiza Nós (Baseado em Node ID) ---

                // Nó A
                if (!nodes[nodeIDA]) {
                    // Nó existe apenas no arquivo de Rádio (Rádio puro)
                    nodes[nodeIDA] = createEmptyNode(nodeIDA);
                }
                // Atualiza/Define dados do Nó A
                nodes[nodeIDA].cen = cenA; // CEN (localização)
                nodes[nodeIDA].lat = latA;
                nodes[nodeIDA].lon = lonA;
                nodes[nodeIDA].clusters.add(cluster); // Associa cluster ao nó

                // Nó B
                if (!nodes[nodeIDB]) {
                    // Nó existe apenas no arquivo de Rádio (Rádio puro)
                    nodes[nodeIDB] = createEmptyNode(nodeIDB);
                }
                // Atualiza/Define dados do Nó B
                nodes[nodeIDB].cen = cenB; // CEN (localização) (agora corrigido para MH-T280)
                nodes[nodeIDB].lat = latB;
                nodes[nodeIDB].lon = lonB;
                nodes[nodeIDB].clusters.add(cluster); // Associa cluster ao nó


                // --- Lógica de VLAN (NOVO) ---
                // O Rádio A herda a VLAN da sub-rede (do mapa mestre)
                const radioSubnetA = getSubnet(ipA);
                const vlanA = subnetVlanMap.get(radioSubnetA) || '-'; // Pega VLAN ou '-'

                // O Rádio B herda a VLAN da sub-rede (do mapa mestre)
                const radioSubnetB = getSubnet(ipB);
                const vlanB = subnetVlanMap.get(radioSubnetB) || '-'; // Pega VLAN ou '-'

                // --- Fim da Lógica de VLAN ---

                // --- Dados específicos do Rádio (Lado A) ---
                const azimuthNumA = parseFloat(azimuthA.replace(',', '.'));
                const sectorNumA = parseInt(sectInDevice, 10); // sectInDevice já tem +1
                
                // Adiciona o Rádio A ao array de rádios do Nó A
                nodes[nodeIDA].radios.push({
                    product: produtoBaseA,
                    ip: ipA,
                    vlan: vlanA,
                    freq: freqA,
                    tddPol: tddPol,
                    sectorNum: !isNaN(sectorNumA) ? sectorNumA : null,
                    azimuth: !isNaN(azimuthNumA) ? azimuthNumA : null
                });

                // NOVO: Associa Setor/Azimute (APENAS LADO A)
                if (produtoBaseA.startsWith("MH-N") && !isNaN(sectorNumA) && !isNaN(azimuthNumA)) {
                    // Armazena o azimute real para este setor
                    nodes[nodeIDA].sectors.set(sectorNumA, azimuthNumA); 
                    
                    // NOVO: Salva o Azimute Base CALCULADO
                    // Tenta salvar o Azimute Base calculado (apenas o primeiro encontrado para este nó)
                    if (nodes[nodeIDA].calculatedBaseAzimuth === undefined && setor1CalculatedAz !== '-') {
                        nodes[nodeIDA].calculatedBaseAzimuth = parseFloat(setor1CalculatedAz.replace('°', ''));
                    }
                }
                
                // Adiciona o Rádio B ao array de rádios do Nó B
                nodes[nodeIDB].radios.push({
                    product: produtoBaseB,
                    ip: ipB,
                    vlan: vlanB,
                    freq: freqB,
                    tddPol: tddPol,
                    sectorNum: null, // Lado B não tem setor MH-N
                    azimuth: null // Lado B não tem setor MH-N
                });

                
                // --- Adiciona Link ---
                links.push({
                    // ATUALIZAÇÃO: Links agora usam Node ID E CEN
                    idA: nodeIDA, // Node ID A
                    idB: nodeIDB, // Node ID B
                    cenA: cenA, // CEN A (para tabela)
                    cenB: cenB, // CEN B (para tabela) (agora corrigido para MH-T280)
                    cluster: cluster, // NOVO: Salva o cluster do link
                    latA: latA, lonA: lonA,
                    latB: latB, lonB: lonB,
                    produtoA: produtoA, 
                    produtoB: produtoB, 
                    tddPol: tddPol,
                    // NOVAS PROPRIEDADES (PARA TABELA)
                    azimuthA: azimuthA,
                    azimuthB: azimuthB,
                    sectInDevice: sectInDevice,
                    txPower: txPower, // NOVO
                    rssi: rssi,       // NOVO
                    setor1CalculatedAzimuth: setor1CalculatedAz, // NOVO (CALCULADO)
                    // FIM NOVAS PROPRIEDADES
                    freqA: freqA,
                    freqB: freqB,
                    // REMOVIDO: baseAzimuthA, baseAzimuthB
                });
            }
        }
        
        /**
         * Renderiza os nós e links no mapa.
         */
        function renderMap(selectedRadius) { // Aceita o raio como argumento
            if (!map) {
                // console.error("Mapa não inicializado.");
                return;
            }

            // Limpa camadas
            mapLayers.markers.clearLayers();
            mapLayers.lines.clearLayers();
            mapLayers.sectors1.clearLayers();
            mapLayers.sectors2.clearLayers();
            mapLayers.sectors3.clearLayers();
            mapLayers.sectors4.clearLayers();
            
            // NOVO: Limpa camadas de cluster dinâmicas (recriadas no processRadioData)
            // (A limpeza real e remoção do controle acontece no clearVisuals)
            
            let bounds = [];

            // Renderiza Marcadores (Nós) - Iterando por Node ID
            for (const nodeID in nodes) {
                const node = nodes[nodeID];
                
                // Só desenha o marcador se o nó tiver coordenadas (veio do arquivo de Rádio)
                if (node.lat && node.lon) {
                    
                    // --- Coleta de IPs e Seriais (para PopUp) ---
                    const allIPs = new Set();
                    if (node.switchIP !== '-') allIPs.add(node.switchIP);
                    node.radios.forEach(r => { if(r.ip !== '-') allIPs.add(r.ip) });
                    
                    const serials = [];
                    allIPs.forEach(ip => {
                        const info = serialMap.get(ip);
                        if (info) {
                            serials.push(`PN: ${info.partNumber}, SN: ${info.serial}`);
                        }
                    });
                    
                    // --- Coleta de Produtos (para PopUp) ---
                    const radioProducts = node.radios.map(r => r.product).filter(p => p !== '-');
                    const radioIPs = node.radios.map(r => r.ip).filter(ip => ip !== '-');
                    const radioVLANs = node.radios.map(r => r.vlan).filter(v => v !== '-');
                    const radioFreqs = node.radios.map(r => r.freq).filter(f => f !== '-');
                    const radioTDDs = node.radios.map(r => r.tddPol).filter(t => t !== '-');

                    // --- Conteúdo do PopUp ---
                    // ATUALIZAÇÃO: Título é Node ID, CEN é atributo
                    let popupContent = `<div class="popup-title">${node.nodeID}</div>`;
                    popupContent += `<strong>CEN (Local):</strong> ${node.cen}<br>`; 
                    popupContent += `<strong>Cluster(s):</strong> ${Array.from(node.clusters).join(', ')}<br>`; 
                    
                    popupContent += `<div class="popup-section">Info Rádio</div>`;
                    popupContent += `<strong>Produto(s):</strong> ${[...new Set(radioProducts)].join(', ')}<br>`;
                    popupContent += `<strong>IP(s):</strong> ${[...new Set(radioIPs)].join(', ')}<br>`;
                    popupContent += `<strong>VLAN(s) Rádio:</strong> ${[...new Set(radioVLANs)].join('<br>') || '-'}<br>`;
                    popupContent += `<strong>Frequência(s):</strong> ${[...new Set(radioFreqs)].join(', ')}<br>`;
                    popupContent += `<strong>TDD-POL:</strong> ${[...new Set(radioTDDs)].join(', ')}<br>`;
                    
                    // ATUALIZAÇÃO: Exibe texto estático para Azimute
                    popupContent += `<strong>Sectores (Azimute):</strong><br>Verificar na Lista de Links`;

                    popupContent += `<div class="popup-section">Equip. Adicional (Switch)</div>`;
                    popupContent += `<strong>Produto:</strong> ${node.switchProduct}<br>`;
                    popupContent += `<strong>IP:</strong> ${node.switchIP}<br>`;
                    popupContent += `<strong>VLAN:</strong> ${node.switchVLAN}<br>`;

                    popupContent += `<div class="popup-section">Seriais (PN/SN)</div>`;
                    popupContent += `${serials.length > 0 ? serials.join('<br>') : '-'}`;

                    const marker = L.marker([node.lat, node.lon])
                        .addTo(mapLayers.markers) // Adiciona à camada principal "Nós"
                        .bindPopup(popupContent);
                    
                    // NOVO: Adiciona marcador às camadas de cluster
                    node.clusters.forEach(clusterName => {
                        if (clusterLayers[clusterName]) {
                            marker.addTo(clusterLayers[clusterName]);
                        }
                    });
                    
                    bounds.push([node.lat, node.lon]);
                    
                    // ATUALIZADO: LÓGICA DE SETOR (MH-N) (vindo do CÁLCULO)
                    if (node.calculatedBaseAzimuth !== undefined) { 
                        const baseAzimuth = node.calculatedBaseAzimuth; // é um float (CALCULADO)
                        const center = [node.lat, node.lon];
                        const radius = selectedRadius || 70; // Usa o raio selecionado
                        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00']; // R, G, B, Y
                        const opacity = 0.2;
                        const sectorLayerGroups = [mapLayers.sectors1, mapLayers.sectors2, mapLayers.sectors3, mapLayers.sectors4];
                        const halfWidth = 45.1; // Sobreposição

                        // Pop-up para o setor (associado ao nó)
                        const sectorPopupContent = `
                            <div class="popup-title">Info Setor (Nó: ${node.nodeID})</div>
                            <strong>CEN:</strong> ${node.cen}<br>
                            <strong>Azimute Base (Setor 1):</strong> ${node.calculatedBaseAzimuth.toFixed(1)}° (Calculado)
                        `;

                        for (let i = 0; i < 4; i++) {
                            const sectorNum = i + 1;
                            // CALCULA O AZIMUTE (SENTIDO HORÁRIO)
                            const sectorCenterAzimuth = (baseAzimuth + (i * 90) + 360) % 360;

                            const sectorIndex = i;
                            const color = colors[sectorIndex];
                            const label = sectorNum.toString();
                            const layerGroup = sectorLayerGroups[sectorIndex];
                            
                            // L.semiCircle usa 0=Norte, sentido HORÁRIO.
                            const leafletStart = (sectorCenterAzimuth - halfWidth + 360) % 360;
                            const leafletStop = (sectorCenterAzimuth + halfWidth + 360) % 360;
                            
                            const sectorLayer = L.semiCircle(center, {
                                radius: radius,
                                startAngle: leafletStart, // Normal
                                stopAngle: leafletStop,  // Normal
                                fill: true,
                                fillColor: color,
                                fillOpacity: opacity,
                                color: color, 
                                opacity: opacity + 0.2,
                                weight: 1
                            })
                            .bindTooltip(label, { 
                                permanent: true,
                                direction: 'center',
                                className: 'sector-label'
                            })
                            .addTo(layerGroup);
                            
                            // Adiciona o popup SOMENTE ao Setor 1
                            if (sectorNum === 1) {
                                sectorLayer.bindPopup(sectorPopupContent);
                            }
                        }
                    }
                }
            }

            // Renderiza Linhas (Links)
            links.forEach(link => {
                let color = '#007bff'; // Azul padrão
                const tdd = link.tddPol.toLowerCase();
                
                if (tdd.includes('odd')) {
                    color = '#d9534f'; // Vermelho
                } else if (tdd.includes('even')) {
                    color = '#5cb85c'; // Verde
                } else if (tdd.includes('p2p')) {
                    color = '#f0ad4e'; // Amarelo
                }

                const polyline = L.polyline([[link.latA, link.lonA], [link.latB, link.lonB]], {
                    color: color,
                    weight: 2,
                    opacity: 0.7
                }).addTo(mapLayers.lines); // Adiciona à camada principal "Links"
                
                // NOVO: Adiciona linha à camada de cluster
                const clusterName = link.cluster;
                if (clusterLayers[clusterName]) {
                    polyline.addTo(clusterLayers[clusterName]);
                }
            });

            // REMOVIDO: Loop de Setores Independentes
            
            // Centraliza o mapa
            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [20, 20] }); 
            }
        }

        /**
         * Renderiza as tabelas de links e inventário.
         */
        function renderTables() {
            const linkListBody = document.getElementById('linkListBody');
            const nodeInventoryBody = document.getElementById('nodeInventoryBody');
            
            linkListBody.innerHTML = '';
            nodeInventoryBody.innerHTML = '';
            
            // Preenche Tabela de Links
            links.forEach(link => {
                const tr = document.createElement('tr');
                tr.className = 'border-b last:border-b-0 hover:bg-gray-50 transition-colors duration-150';
                
                tr.innerHTML = `
                    <!-- NOVO: Coluna Cluster -->
                    <td class="py-3 px-4">${link.cluster}</td> 
                    <!-- ATUALIZAÇÃO: Mostra CEN A e CEN B -->
                    <td class="py-3 px-4">${link.cenA}</td>
                    <td class="py-3 px-4">${link.cenB}</td>
                    <td class="py-3 px-4">${link.produtoA}</td>
                    <td class="py-3 px-4">${link.produtoB}</td>
                    <td class="py-3 px-4">${link.tddPol}</td>
                    <td class="py-3 px-4">${link.azimuthA}</td>
                    <td class="py-3 px-4">${link.azimuthB}</td>
                    <td class="py-3 px-4">${link.sectInDevice}</td>
                    <!-- NOVAS CÉLULAS ADICIONADAS -->
                    <td class="py-3 px-4">${link.txPower}</td>
                    <td class="py-3 px-4">${link.rssi}</td>
                    <!-- FIM NOVAS CÉLULAS -->
                    <td class="py-3 px-4">${link.freqA}</td>
                    <td class="py-3 px-4">${link.freqB}</td>
                    <!-- NOVO: Célula Setor 1 (Azimute) -->
                    <td class="py-3 px-4">${link.setor1CalculatedAzimuth}</td>
                `;
                linkListBody.appendChild(tr);
            });

            // Preenche Tabela de Inventário (Baseado em Node ID)
            
            // 1. Converte o objeto 'nodes' para um array
            const nodesArray = Object.values(nodes);
            
            // 2. Classifica o array pelo Cluster
            nodesArray.sort((a, b) => {
                const clusterA = Array.from(a.clusters).join(', ') || 'ZZZ'; // Joga 'Sem Cluster' para o final
                const clusterB = Array.from(b.clusters).join(', ') || 'ZZZ';
                return clusterA.localeCompare(clusterB);
            });
            
            // 3. Itera sobre o array classificado e cria as linhas
            for (const node of nodesArray) {
                
                const nodeID = node.nodeID;
                const cen = node.cen || 'N/A';
                const cluster = Array.from(node.clusters).join('<br>') || '-';
                
                const hasSwitch = node.switchProduct !== '-';
                const hasRadios = node.radios.length > 0;
                
                // ATUALIZAÇÃO: Lógica para separar Rádios e Switches
                
                // Linha 1: Se for um Switch
                if (hasSwitch) {
                    // ATUALIZAÇÃO: Busca o objeto de serial
                    const switchSerialInfo = serialMap.get(node.switchIP) || { serial: '-', partNumber: '-' };
                    
                    const trSwitch = document.createElement('tr');
                    trSwitch.className = 'border-b last:border-b-0 hover:bg-gray-50 transition-colors duration-150';
                    trSwitch.innerHTML = `
                        <td class="py-3 px-4 align-top">${cluster}</td>
                        <td class="py-3 px-4 align-top font-semibold">${cen}</td>
                        <td class="py-3 px-4 align-top">${nodeID}</td>
                        <td class="py-3 px-4 align-top">${node.switchProduct}</td>
                        <td class="py-3 px-4 align-top">${node.switchIP}</td>
                        <td class="py-3 px-4 align-top">${node.switchVLAN}</td>
                        <!-- NOVO: Célula Part Number -->
                        <td class="py-3 px-4 align-top">${switchSerialInfo.partNumber}</td>
                        <td class="py-3 px-4 align-top">${switchSerialInfo.serial}</td>
                    `;
                    nodeInventoryBody.appendChild(trSwitch);
                }
                
                // Linhas 2...N: Se tiver Rádios (Um para cada rádio)
                if (hasRadios) {
                    
                    node.radios.forEach(radio => {
                        const radioIP = radio.ip || '-';
                        // ATUALIZAÇÃO: Busca o objeto de serial
                        const radioSerialInfo = serialMap.get(radioIP) || { serial: '-', partNumber: '-' };
                        const radioProduct = radio.product || '-';
                        const radioVLAN = radio.vlan || '-';

                        const trRadio = document.createElement('tr');
                        trRadio.className = 'border-b last:border-b-0 hover:bg-gray-50 transition-colors duration-150';
                        trRadio.innerHTML = `
                            <td class="py-3 px-4 align-top">${cluster}</td>
                            <td class="py-3 px-4 align-top font-semibold">${cen}</td>
                            <td class="py-3 px-4 align-top">${nodeID}</td>
                            <td class="py-3 px-4 align-top">${radioProduct}</td>
                            <td class="py-3 px-4 align-top">${radioIP}</td>
                            <td class="py-3 px-4 align-top">${radioVLAN}</td>
                            <!-- NOVO: Célula Part Number -->
                            <td class="py-3 px-4 align-top">${radioSerialInfo.partNumber}</td>
                            <td class="py-3 px-4 align-top">${radioSerialInfo.serial}</td>
                        `;
                        nodeInventoryBody.appendChild(trRadio);
                    });
                }
                
                // Se o nó não tiver nem switch nem rádio (veio só do Seriais, por ex?)
                // Não será desenhado (pois não tem produto)
            }
        }

        /**
         * Limpa o mapa e as tabelas antes de um novo carregamento.
         */
        function clearVisuals() {
            if (mapLayers.markers) mapLayers.markers.clearLayers();
            if (mapLayers.lines) mapLayers.lines.clearLayers();
            if (mapLayers.sectors1) mapLayers.sectors1.clearLayers();
            if (mapLayers.sectors2) mapLayers.sectors2.clearLayers();
            if (mapLayers.sectors3) mapLayers.sectors3.clearLayers();
            if (mapLayers.sectors4) mapLayers.sectors4.clearLayers();
            
            // NOVO: Limpa e remove camadas de cluster dinâmicas
            if (layerControl) {
                for (const clusterName in clusterLayers) {
                    layerControl.removeLayer(clusterLayers[clusterName]); // Remove do controle
                    clusterLayers[clusterName].clearLayers(); // Limpa a camada
                }
            }
            clusterLayers = {}; // Reseta o objeto


            document.getElementById('linkListBody').innerHTML = '';
            document.getElementById('nodeInventoryBody').innerHTML = '';
            
            document.getElementById('tablesContainer').classList.add('hidden');
        }

        /**
         * Exibe uma mensagem de status ou erro.
         */
        function showMessage(message, isError = false) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            messageBox.className = 'mt-4 p-3 rounded-md text-sm text-center'; // Reseta classes
            
            if (isError) {
                messageBox.classList.add('bg-red-100', 'text-red-700');
            } else {
                messageBox.classList.add('bg-blue-100', 'text-blue-700');
            }
            
            messageBox.classList.remove('hidden');
        }

        /**
         * Controla a lógica de troca de abas.
         */
        function openTab(event, tabID) {
            // Esconde todos os conteúdos
            const tabContents = document.getElementsByClassName('tab-content');
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove('active');
            }
            
            // Remove 'active' de todos os botões
            const tabButtons = document.getElementsByClassName('tab-button');
            for (let i = 0; i < tabButtons.length; i++) {
                tabButtons[i].classList.remove('active');
            }
            
            // Mostra o conteúdo da aba clicada e ativa o botão
            document.getElementById(tabID).classList.add('active');
            event.currentTarget.classList.add('active');
        }

        // --- Event Listeners ---
        document.getElementById('generateButton').addEventListener('click', handleFiles);
        // Inicializa o mapa QUANDO A PÁGINA INTEIRA CARREGAR (incluindo scripts)
        window.addEventListener('load', initMap);

    </script>
</body>
</html>

