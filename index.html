<!DOCTYPE html>
<html lang="pt-br"> 
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de Topologia de Rede - V1.6.9</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        /* Define a altura do mapa */
        #map { height: 70vh; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        body { font-family: 'Inter', sans-serif; }
        
        /* Estilos das Abas */
        .tab-button {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            border-radius: 0.375rem 0.375rem 0 0;
            font-weight: 500;
            background-color: #f3f4f6; /* bg-gray-100 */
            color: #4b5563; /* text-gray-600 */
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }
        .tab-button.active {
            background-color: #ffffff; /* bg-white */
            color: #1d4ed8; /* text-blue-700 */
            border-bottom: 2px solid #1d4ed8; /* border-blue-700 */
        }
        .tab-content {
            display: none;
            background-color: #ffffff;
            border-radius: 0 0 0.5rem 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        .tab-content.active {
            display: block;
        }

        /* Estilo para a tabela com "scroll" */
        .table-container {
            max-height: 60vh;
            overflow-y: auto;
        }
        /* Fixar o cabeçalho da tabela */
        .table-container thead th {
            position: sticky;
            top: 0;
            background-color: #f9fafb; /* bg-gray-50 */
            z-index: 10;
        }

        /* Remove setas do input[type=number] */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }

        /* Pop-up do Leaflet personalizado */
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
        }
        .leaflet-popup-content {
            font-size: 13px;
            line-height: 1.6;
        }
        .popup-title {
            font-weight: 700;
            font-size: 1.1rem;
            color: #1d4ed8;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-bottom: 8px;
        }
        .popup-section {
            font-weight: 600;
            color: #374151; /* text-gray-700 */
            margin-top: 10px;
        }
        
        /* Estilo para os rótulos dos setores no mapa */
        .sector-label {
            background: transparent;
            border: 0;
            box-shadow: none;
            color: #000000;
            font-weight: bold;
            font-size: 11px;
            text-shadow: 1px 1px 2px #fff, -1px -1px 2px #fff, 1px -1px 2px #fff, -1px 1px 2px #fff;
        }

        /* Estilos para controles customizados do Leaflet */
        .leaflet-control-resetzoom a,
        .leaflet-control-northarrow div {
            width: 30px;
            height: 30px;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            text-decoration: none;
            color: #000;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }
        .leaflet-control-resetzoom a {
            cursor: pointer;
        }
        .leaflet-control-northarrow div {
            cursor: default;
            padding-top: 2px;
        }
        .leaflet-bar a, .leaflet-bar div {
             border-bottom: 1px solid #ccc;
        }
        .leaflet-bar a:last-child, .leaflet-bar div:last-child {
             border-bottom: none;
        }

    </style>
</head>

<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8"> 
        
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-blue-700">Visualizador de Topologia de Rede</h1>
            <p class="text-md text-gray-600 mt-1">Carregue os arquivos CSV para gerar o mapa e as tabelas. (V1.6.9)</p>
        </header>

        <div class="bg-white p-6 rounded-lg shadow-md mb-6">
            <div class="grid grid-cols-1 md:grid-cols-6 gap-4 items-end">
                
                <div class="md:col-span-1">
                    <label for="csvRadio" class="block text-sm font-medium text-gray-700 mb-1">1. Rádio (Delimitador: ;)</label>
                    <input type="file" id="csvRadio" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors">
                </div>
                
                <div class="md:col-span-1">
                    <label for="csvSwitch" class="block text-sm font-medium text-gray-700 mb-1">2. Switch (Delimitador: ;)</label>
                    <input type="file" id="csvSwitch" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors">
                </div>
                
                <div class="md:col-span-1">
                    <label for="csvSeriais" class="block text-sm font-medium text-gray-700 mb-1">3. Seriais (Delimitador: ;)</label>
                    <input type="file" id="csvSeriais" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors">
                </div>

                <div class="md:col-span-1">
                    <label for="sectorRadius" class="block text-sm font-medium text-gray-700 mb-1">Raio Setor (m)</label>
                    <select id="sectorRadius" class="block w-full text-sm text-gray-900 border border-gray-300 rounded-md py-2 px-3 focus:ring-blue-500 focus:border-blue-500 transition-colors">
                        <option value="50" selected>50m</option>
                        <option value="150">150m</option>
                        <option value="300">300m</option>
                    </select>
                </div>
                
                <button id="generateButton" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md font-semibold hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors shadow-sm md:col-span-2">
                    Gerar Topologia
                </button>
            </div>
            
            <div id="messageBox" class="mt-4 p-3 rounded-md text-sm text-center hidden"></div>
        </div>

        <div id="mapContainer" class="mb-6">
            <div id="map"></div>
        </div>
        
        <div id="tablesContainer" class="hidden">
            
            <div id="exportButtonContainer" class="mb-4 text-right">
                <button id="exportButton" class="bg-green-600 text-white py-2 px-4 rounded-md font-semibold hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 transition-colors shadow-sm">
                    Exportar CSV Completo
                </button>
            </div>
            <div class="flex border-b border-gray-300">
                <button class="tab-button active" onclick="openTab(event, 'linksTab')">Lista de Links</button>
                <button class="tab-button" onclick="openTab(event, 'inventoryTab')">Inventário de Nós</button>
            </div>
            
            <div id="linksTab" class="tab-content active">
                <div class="table-container">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Cluster</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">CEN A</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">CEN B</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Produto A</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Produto B</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Polarization</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">TDD-POL</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">TX Power A/B (dBm)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Freq. A (MHz)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Freq. B (MHz)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">TX op-mode A/B</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">RSSI (dBm) A/B</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Setor 1 (Azimute)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Sect-In-Device</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Azimute A (deg)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Azimute B (deg)</th>
                            </tr>
                        </thead>
                        <tbody id="linkListBody" class="bg-white divide-y divide-gray-200">
                            </tbody>
                    </table>
                </div>
            </div>
            
            <div id="inventoryTab" class="tab-content">
                <div class="table-container">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Cluster(s)</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">CEN</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Node ID</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Produtos</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">IPs</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">VLANs</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Part Number</th>
                                <th scope="col" class="py-3.5 px-4 text-left text-sm font-semibold text-gray-600">Serial Number</th>
                            </tr>
                        </thead>
                        <tbody id="nodeInventoryBody" class="bg-white divide-y divide-gray-200">
                            </tbody>
                    </table>
                </div>
            </div>

        </div>

    </div> <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-semicircle@2.0.4/Semicircle.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <script>
        // Variável global para o mapa
        let map;
        let layerControl; 
        
        const mapLayers = {
            markers: null,
            lines: null,
            sectors1: null,
            sectors2: null,
            sectors3: null,
            sectors4: null
        };
        let clusterLayers = {}; 

        // Dados globais processados
        let nodes = {};
        let links = [];
        let serialMap = new Map(); 
        let subnetVlanMap = new Map();

        /**
         * Inicializa o mapa Leaflet assim que a página carrega.
         */
        function initMap() {
            if (map) return; 
            
            try {
                map = L.map('map').setView([-14.2350, -51.9253], 5); 
                const baseTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                
                mapLayers.markers = L.layerGroup().addTo(map);
                mapLayers.lines = L.layerGroup().addTo(map);
                
                mapLayers.sectors1 = L.layerGroup().addTo(map);
                mapLayers.sectors2 = L.layerGroup().addTo(map);
                mapLayers.sectors3 = L.layerGroup().addTo(map);
                mapLayers.sectors4 = L.layerGroup().addTo(map);

                const baseMaps = {
                    "OpenStreetMap": baseTileLayer
                };
                const overlayMaps = {
                    "Links": mapLayers.lines,
                    "Nós (Markers)": mapLayers.markers,
                    "Setor 1 (MH-N)": mapLayers.sectors1,
                    "Setor 2 (MH-N)": mapLayers.sectors2,
                    "Setor 3 (MH-N)": mapLayers.sectors3,
                    "Setor 4 (MH-N)": mapLayers.sectors4
                };
                
                layerControl = L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);

                // --- Adiciona Controles de Reset e Norte ---
                const ResetZoomControl = L.Control.extend({
                    options: { position: 'topleft' },
                    onAdd: function (map) {
                        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-resetzoom');
                        const link = L.DomUtil.create('a', '', container);
                        link.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>`;
                        link.href = '#';
                        link.title = 'Resetar Zoom';
                        L.DomEvent.on(link, 'click', L.DomEvent.stop);
                        L.DomEvent.on(link, 'click', () => map.setView([-14.2350, -51.9253], 5));
                        return container;
                    }
                });
                map.addControl(new ResetZoomControl());

                const NorthArrowControl = L.Control.extend({
                    options: { position: 'topleft' },
                    onAdd: function (map) {
                        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-northarrow');
                        container.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2.5"><path d="M12 19V5M12 5L8 9M12 5L16 9"></path><text x="12" y="4" font-size="8" fill="#333" font-weight="600" text-anchor="middle">N</text></svg>`;
                        container.title = 'Norte';
                        return container;
                    }
                });
                map.addControl(new NorthArrowControl());
                
                // --- Fim dos Novos Controles ---

                const legend = L.control({ position: 'bottomright' });
                legend.onAdd = function (map) {
                    const div = L.DomUtil.create('div', 'info legend');
                    const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
                    const labels = ['Setor 1', 'Setor 2', 'Setor 3', 'Setor 4'];
                    let legendHtml = '<div style="background:white; padding: 10px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.2);">';
                    legendHtml += '<strong style="display:block; margin-bottom: 5px;">Legenda (MH-N)</strong>';
                    const iStyle = 'width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.7;';
                    for (let i = 0; i < labels.length; i++) {
                        legendHtml += `<div><i style="${iStyle} background:${colors[i]}"></i> ${labels[i]}</div>`;
                    }
                    legendHtml += '</div>';
                    div.innerHTML = legendHtml;
                    return div;
                };
                legend.addTo(map);

            } catch (e) {
                console.error("Erro ao inicializar o mapa Leaflet:", e);
                showMessage("Erro fatal ao carregar o mapa. Verifique a conexão com a internet.", true);
            }
        }

        /**
         * Remove o BOM (Byte Order Mark) invisível do início do texto do CSV.
         */
        function cleanCSVText(text) {
            if (text.charCodeAt(0) === 0xFEFF) {
                return text.substring(1);
            }
            return text;
        }
        
        const parseCoord = (val) => {
            if (!val) return NaN;
            const strVal = val.trim();
            if (strVal.includes('.') || strVal.includes(',')) {
                let coord = parseFloat(strVal.replace(',', '.'));
                if (!isNaN(coord)) {
                    return coord;
                }
            }
            const numVal = parseFloat(strVal);
            if (!isNaN(numVal) && Math.abs(numVal) > 1000) { 
                const strNum = numVal.toString();
                const splitIndex = strNum.startsWith('-') ? 3 : 2; 
                const result = parseFloat(strNum.substring(0, splitIndex) + '.' + strNum.substring(splitIndex));
                
                if (!isNaN(result)) {
                    return result;
                }
            }
            return parseFloat(strVal.replace(',', '.'));
        };


        /**
         * Converte texto CSV em um array de objetos.
         */
        async function parseCSV(file, delimiter = ';') {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const csvText = event.target.result;
                        const cleanedText = cleanCSVText(csvText);
                        
                        const lines = cleanedText.split(/\r?\n/).filter(line => line.trim() !== '');

                        if (lines.length === 0) {
                             reject(new Error("Arquivo CSV está vazio."));
                             return;
                        }

                        const headers = lines[0].split(delimiter).map(h => h.trim());
                        
                        if (headers.length === 0 || (headers.length === 1 && headers[0] === '')) {
                            reject(new Error("Cabeçalho do CSV não encontrado ou mal formatado."));
                            return;
                        }

                        const rows = lines.slice(1).map(line => {
                            const values = line.split(delimiter);
                            return headers.reduce((obj, header, index) => {
                                obj[header] = values[index] ? values[index].trim() : '';
                                return obj;
                            }, {});
                        });
                        
                        resolve({ headers, rows });

                    } catch (e) {
                         reject(new Error(`Erro ao processar CSV: ${e.message}`));
                    }
                };
                reader.onerror = () => {
                     reject(new Error("Não foi possível ler o arquivo."));
                };
                reader.readAsText(file);
            });
        }
        
        const getSubnet = (ip) => {
            if (!ip || ip === '-') return null;
            return ip.split('.').slice(0, 3).join('.');
        }

        /**
         * Função principal para ler e processar os arquivos.
         */
        async function handleFiles() {
            const fileRadio = document.getElementById('csvRadio').files[0];
            const fileSwitch = document.getElementById('csvSwitch').files[0];
            const fileSeriais = document.getElementById('csvSeriais').files[0];

            const selectedRadius = parseInt(document.getElementById('sectorRadius').value, 10);

            if (!fileRadio || !fileSwitch) { 
                showMessage("Por favor, selecione pelo menos os arquivos Rádio e Switch.", true);
                return;
            }

            // Reseta os dados globais
            nodes = {};
            links = [];
            serialMap.clear();
            subnetVlanMap.clear(); 
            
            clearVisuals();
            showMessage("Processando arquivos...", false);
            
            try {
                // 1. Lê o arquivo de Seriais (IP -> Serial) - OPCIONAL
                if (fileSeriais) {
                    try {
                        const serialData = await parseCSV(fileSeriais, ';');
                        serialData.rows.forEach(row => {
                            const ip = row['IP']?.trim();
                            const serial = row['Serial Number']?.trim();
                            const partNumber = row['Part Number']?.trim() || '-'; 
                            
                            if (ip && (serial || partNumber !== '-')) {
                                serialMap.set(ip, { 
                                    serial: serial || '-', 
                                    partNumber: partNumber 
                                });
                            }
                        });
                    } catch (e) {
                         console.warn("Arquivo de seriais não pôde ser processado, continuando...");
                    }
                }

                // 2. Lê o arquivo de Switch (Gera o subnetVlanMap)
                const switchData = await parseCSV(fileSwitch, ';');
                if (switchData.rows.length === 0) {
                    throw new Error("Arquivo de Switch não contém dados.");
                }
                processSwitchData(switchData.rows);
                
                // 3. Lê o arquivo de Rádio (Usa o subnetVlanMap)
                const radioData = await parseCSV(fileRadio, ';');
                if (radioData.rows.length === 0) {
                    throw new Error("Arquivo de Rádio não contém dados.");
                }
                processRadioData(radioData.rows); 

                // 4. Renderiza tudo
                renderMap(selectedRadius); 
                renderTables();

                document.getElementById('tablesContainer').classList.remove('hidden');
                // ====================================================================
                // 4. MOSTRAR BOTÃO DE EXPORTAR
                // ====================================================================
                document.getElementById('exportButtonContainer').classList.remove('hidden');
                
                const nodesComRadio = Object.values(nodes).filter(n => n.lat !== null).length;
                showMessage(`Topologia gerada com sucesso! ${nodesComRadio} nós com rádio e ${links.length} links encontrados.`, false);

            } catch (error) {
                console.error("Erro no processamento dos arquivos:", error);
                showMessage(`Erro no processamento dos arquivos: ${error.message}`, true);
            }
        }

        /**
         * Processa os dados do arquivo de Switch.
         */
        function processSwitchData(rows) {
            for (const row of rows) {
                const nodeID = row['Node ID']?.trim();
                
                let product = row['DESCRIÇÃO']?.trim() || '-';
                
                // "Traduz" o nome do produto
                switch (product) {
                    case "Sw 4 portas":
                        product = "Planet IGS-4215-4UP4T2S";
                        break;
                    case "Sw 8 portas":
                        product = "Planet IGS-4215-8UP2T2S";
                        break;
                    case "Planet switch SGS-6310-8P4X - 10G":
                        product = "Planet SGS-6310-8P4X";
                        break;
                }

                const ipMask = row['IP/Mascara']?.trim() || '-';
                const vlan = row['VLAN']?.trim() || '-';
                
                const ip = ipMask.split('/')[0] || '-';

                if (!nodeID) continue; 

                // 1. Atualiza/Cria o Nó no inventário
                if (!nodes[nodeID]) {
                    nodes[nodeID] = {
                        nodeID: nodeID,
                        cen: row['CEN']?.trim() || '-', 
                        lat: null, 
                        lon: null, 
                        radioProducts: [], 
                        switchProduct: product, 
                        switchIP: ip,
                        switchVLAN: vlan,
                        freqRadios: new Set(),
                        tddPols: new Set(),
                        clusters: new Set(), 
                        polarizations: new Set(),
                        sectors: new Map(), 
                    };
                } else {
                    nodes[nodeID].switchProduct = product; 
                    nodes[nodeID].switchIP = ip;
                    nodes[nodeID].switchVLAN = vlan;
                }

                // 2. Alimenta o Mapa Mestre de VLANs
                const subnet = getSubnet(ip);
                if (subnet && vlan !== '-' && !subnetVlanMap.has(subnet)) {
                    subnetVlanMap.set(subnet, vlan);
                }
            }
        }
        
        /**
         * Processa os dados do arquivo de Rádio.
         */
        function processRadioData(rows) { 
            
            const parseSectorRule = (val) => {
                const trimmedVal = val?.trim();
                const num = parseInt(trimmedVal, 10);
                if (!isNaN(num)) {
                    return (num + 1).toString(); // Soma +1
                }
                return trimmedVal || '-';
            };

            for (const row of rows) {
                let cenA = row['CEN A']?.trim();
                let cenB = row['CEN B']?.trim();
                const nodeIDA = row['Node ID A']?.trim();
                const nodeIDB = row['Node ID B']?.trim();

                if (!nodeIDA || !nodeIDB) continue; 

                let latA = parseCoord(row['Node Lat A']);
                let lonA = parseCoord(row['Node Lon A']);
                let latB = parseCoord(row['Node Lat B']);
                let lonB = parseCoord(row['Node Lon B']);

                if (isNaN(latA) || isNaN(lonA) || isNaN(latB) || isNaN(lonB)) {
                    continue; 
                }
                
                const cluster = row['CLUSTER']?.trim() || 'Sem Cluster';

                if (cluster !== 'Sem Cluster' && !clusterLayers[cluster]) {
                    const newLayer = L.layerGroup().addTo(map);
                    clusterLayers[cluster] = newLayer;
                    layerControl.addOverlay(newLayer, cluster);
                }

                const productRaw = row['Product']?.trim() || '-';
                let produtoA, produtoB;
                let produtoBaseA, produtoBaseB; 

                if (productRaw.includes(" - ")) {
                    const parts = productRaw.split(" - ");
                    produtoA = parts[0]?.trim() || '-';
                    produtoB = parts[1]?.trim() || '-';
                } else {
                    produtoA = productRaw;
                    produtoB = productRaw !== '-' ? `${productRaw} (R)` : '-';
                }

                produtoBaseA = produtoA;
                produtoBaseB = produtoB; 
                
                if (productRaw.includes("MH-T280") || productRaw.includes("EH-8010FX")) {
                    cenB = cenA; 
                }

                const ipA = row['IP address A']?.trim() || '-';
                const ipB = row['IP address B']?.trim() || '-';
                const freqA = row['TX freq (MHz) A']?.trim() || '-';
                const freqB = row['TX freq (MHz) B']?.trim() || '-';
                const tddPol = row['TDD-pol']?.trim() || '-';
                
                const azimuthA = row['Antenna Azimuth (deg) A']?.trim() || '-';
                const azimuthB = row['Antenna Azimuth (deg) B']?.trim() || '-';
                const sectInDevice = parseSectorRule(row['Sect-In-Device index']);
                
                const txPower = row['TX Power A/B (dBm)']?.trim() || '-';
                const rssi = row['RSSI (dBm) A/B']?.trim() || '-';
                
                const polarization = row['Polarization']?.trim() || '-';
                const txOpMode = row['TX op-mode A/B']?.trim() || '-';
                
                
                let setor1CalculatedAz = '-';
                const sectorNumN = parseInt(sectInDevice, 10);
                const azimuthNumAz = parseFloat(azimuthA.replace(',', '.'));
                
                if (produtoBaseA.startsWith("MH-N") && !isNaN(sectorNumN) && !isNaN(azimuthNumAz)) {
                    const calculatedAz = azimuthNumAz - ((sectorNumN - 1) * 90);
                    const normalizedAz = (calculatedAz % 360 + 360) % 360;
                    setor1CalculatedAz = `${normalizedAz.toFixed(1)}°`;
                }

                const radioSubnetA = getSubnet(ipA);
                const vlanA = subnetVlanMap.get(radioSubnetA) || '-'; 
                const radioSubnetB = getSubnet(ipB);
                const vlanB = subnetVlanMap.get(radioSubnetB) || '-'; 
                
                if (!nodes[nodeIDA]) {
                    nodes[nodeIDA] = {
                        nodeID: nodeIDA,
                        cen: cenA,
                        lat: latA,
                        lon: lonA,
                        radioProducts: [], 
                        switchProduct: '-', 
                        switchIP: '-',
                        switchVLAN: '-',
                        freqRadios: new Set(),
                        tddPols: new Set(),
                        clusters: new Set(), 
                        polarizations: new Set(),
                        sectors: new Map(), 
                        calculatedBaseAzimuth: undefined 
                    };
                } else {
                    nodes[nodeIDA].lat = latA;
                    nodes[nodeIDA].lon = lonA;
                    nodes[nodeIDA].cen = cenA;
                }
                
                if (!nodes[nodeIDB]) {
                    nodes[nodeIDB] = {
                        nodeID: nodeIDB,
                        cen: cenB,
                        lat: latB,
                        lon: lonB,
                        radioProducts: [], 
                        switchProduct: '-',
                        switchIP: '-',
                        switchVLAN: '-',
                        freqRadios: new Set(),
                        tddPols: new Set(),
                        clusters: new Set(), 
                        polarizations: new Set(),
                        sectors: new Map() 
                    };
                } else {
                    nodes[nodeIDB].lat = latB;
                    nodes[nodeIDB].lon = lonB;
                    nodes[nodeIDB].cen = cenB;
                }

                nodes[nodeIDA].radioProducts.push({
                    product: produtoBaseA,
                    ip: ipA,
                    vlan: vlanA 
                });

                nodes[nodeIDA].freqRadios.add(freqA);
                nodes[nodeIDA].tddPols.add(tddPol);
                nodes[nodeIDA].clusters.add(cluster);
                nodes[nodeIDA].polarizations.add(polarization);

                const azimuthNumA = parseFloat(azimuthA.replace(',', '.'));
                const sectorNumA = parseInt(sectInDevice, 10);
                if (produtoBaseA.startsWith("MH-N") && !isNaN(sectorNumA) && !isNaN(azimuthNumA)) {
                    nodes[nodeIDA].sectors.set(sectorNumA, azimuthNumA); 
                    
                    if (nodes[nodeIDA].calculatedBaseAzimuth === undefined && setor1CalculatedAz !== '-') {
                        nodes[nodeIDA].calculatedBaseAzimuth = parseFloat(setor1CalculatedAz.replace('°', ''));
                    }
                }

                nodes[nodeIDB].radioProducts.push({
                    product: produtoBaseB,
                    ip: ipB,
                    vlan: vlanB 
                });
                
                nodes[nodeIDB].freqRadios.add(freqB);
                nodes[nodeIDB].tddPols.add(tddPol);
                nodes[nodeIDB].clusters.add(cluster);
                nodes[nodeIDB].polarizations.add(polarization);
                
                // --- Adiciona Link ---
                links.push({
                    idA: nodeIDA,
                    idB: nodeIDB,
                    cenA: cenA, 
                    cenB: cenB, 
                    cluster: cluster, 
                    latA: latA, lonA: lonA,
                    latB: latB, lonB: lonB,
                    produtoA: produtoA, 
                    produtoB: produtoB, 
                    tddPol: tddPol,
                    azimuthA: azimuthA,
                    azimuthB: azimuthB,
                    sectInDevice: sectInDevice,
                    txPower: txPower,
                    rssi: rssi,      
                    setor1CalculatedAzimuth: setor1CalculatedAz,
                    freqA: freqA,
                    freqB: freqB,
                    polarization: polarization, 
                    txOpMode: txOpMode,
                    
                    // ====================================================================
                    // 1. ADICIONAR IPs AO LINK
                    // ====================================================================
                    ipA: ipA,
                    ipB: ipB
                });
            }
        }
        
        /**
         * Renderiza os nós e links no mapa.
         */
        function renderMap(selectedRadius) { 
            if (!map) {
                return; 
            }

            mapLayers.markers.clearLayers();
            mapLayers.lines.clearLayers();
            mapLayers.sectors1.clearLayers();
            mapLayers.sectors2.clearLayers();
            mapLayers.sectors3.clearLayers();
            mapLayers.sectors4.clearLayers();
            
            let bounds = [];

            // Renderiza Marcadores (Nós)
            for (const nodeID in nodes) {
                const node = nodes[nodeID];
                
                if (node.lat && node.lon) {
                    
                    const radioIPs = node.radioProducts.map(r => r.ip).filter(ip => ip !== '-');
                    const allIPs = radioIPs.concat(node.switchIP !== '-' ? [node.switchIP] : []);
                    const serialObjects = allIPs.map(ip => serialMap.get(ip)).filter(Boolean); 
                    
                    const radioProducts = node.radioProducts.map(r => r.product).filter(p => p !== '-');
                    const radioVLANs = node.radioProducts.map(r => r.vlan).filter(v => v !== '-');
                    const polarizations = Array.from(node.polarizations).filter(p => p !== '-');

                    let popupContent = `<div class="popup-title">Node ID: ${node.nodeID}</div>`;
                    popupContent += `<strong>CEN:</strong> ${node.cen}<br>`; 
                    popupContent += `<strong>Cluster(s):</strong> ${Array.from(node.clusters).join(', ')}<br>`; 
                    
                    popupContent += `<div class="popup-section">Info Rádio</div>`;
                    popupContent += `<strong>Produto(s):</strong> ${radioProducts.length > 0 ? radioProducts.join('<br>') : '-'}<br>`;
                    popupContent += `<strong>IP(s):</strong> ${radioIPs.length > 0 ? radioIPs.join('<br>') : '-'}<br>`;
                    popupContent += `<strong>VLAN(s) Rádio:</strong> ${radioVLANs.length > 0 ? [...new Set(radioVLANs)].join('<br>') : '-'}<br>`; 
                    popupContent += `<strong>Frequência(s):</strong> ${Array.from(node.freqRadios).filter(f => f !== '-').join(', ')}<br>`;
                    popupContent += `<strong>Pol.:</strong> ${polarizations.length > 0 ? [...new Set(polarizations)].join(', ') : '-'}<br>`;
                    popupContent += `<strong>TDD-POL:</strong> ${Array.from(node.tddPols).filter(p => p !== '-').join(', ')}<br>`;

                    popupContent += `<div class="popup-section">Equip. Adicional (Switch)</div>`;
                    popupContent += `<strong>Produto:</strong> ${node.switchProduct}<br>`; 
                    popupContent += `<strong>IP:</strong> ${node.switchIP}<br>`; 
                    popupContent += `<strong>VLAN:</strong> ${node.switchVLAN}<br>`; 

                    popupContent += `<div class="popup-section">Seriais</div>`;
                
                    if (serialObjects.length > 0) {
                        let serialHtml = '';
                        const seen = new Set(); 

                        serialObjects.forEach(s => {
                            const key = `${s.partNumber}|${s.serial}`;
                            if (s.partNumber !== '-' || s.serial !== '-') {
                                if (!seen.has(key)) {
                                    serialHtml += `<strong>PN:</strong> ${s.partNumber}<br><strong>SN:</strong> ${s.serial}<br><br>`;
                                    seen.add(key);
                                }
                            }
                        });

                        if (serialHtml.length > 0) {
                            popupContent += serialHtml.slice(0, -8); 
                        } else {
                            popupContent += `-`;
                        }
                    } else {
                        popupContent += `-`;
                    }

                    const marker = L.marker([node.lat, node.lon])
                        .addTo(mapLayers.markers) 
                        .bindPopup(popupContent);
                    
                    node.clusters.forEach(clusterName => {
                        if (clusterLayers[clusterName]) {
                            marker.addTo(clusterLayers[clusterName]);
                        }
                    });
                    
                    bounds.push([node.lat, node.lon]);
                    
                    if (node.calculatedBaseAzimuth !== undefined) { 
                        const baseAzimuth = node.calculatedBaseAzimuth; 
                        const center = [node.lat, node.lon];
                        const radius = selectedRadius || 50; 
                        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00']; 
                        const opacity = 0.2;
                        const sectorLayerGroups = [mapLayers.sectors1, mapLayers.sectors2, mapLayers.sectors3, mapLayers.sectors4];
                        const halfWidth = 45.1; 

                        const sectorPopupContent = `
                            <div class="popup-title">Info Setor (Node: ${node.nodeID})</div>
                            <strong>CEN:</strong> ${node.cen}<br>
                            <strong>Node ID:</strong> ${node.nodeID}<br>
                            <strong>Azimute Base (Setor 1):</strong> ${node.calculatedBaseAzimuth.toFixed(1)}° (Calculado)
                        `;

                        for (let i = 0; i < 4; i++) {
                            const sectorNum = i + 1;
                            const sectorCenterAzimuth = (baseAzimuth + (i * 90) + 360) % 360;

                            const sectorIndex = i;
                            const color = colors[sectorIndex];
                            const label = sectorNum.toString();
                            const layerGroup = sectorLayerGroups[sectorIndex];
                            
                            const leafletStart = (sectorCenterAzimuth - halfWidth + 360) % 360;
                            const leafletStop = (sectorCenterAzimuth + halfWidth + 360) % 360;
                            
                            const sectorLayer = L.semiCircle(center, {
                                radius: radius,
                                startAngle: leafletStart, 
                                stopAngle: leafletStop, 
                                fill: true,
                                fillColor: color,
                                fillOpacity: opacity,
                                color: color, 
                                opacity: opacity + 0.2,
                                weight: 1
                            })
                            .bindTooltip(label, { 
                                permanent: true,
                                direction: 'center',
                                className: 'sector-label'
                            })
                            .addTo(layerGroup);
                            
                            if (sectorNum === 1) {
                                sectorLayer.bindPopup(sectorPopupContent);
                            }
                        }
                    }
                }
            }

            // Renderiza Linhas (Links)
            links.forEach(link => {
                let color = '#007bff'; 
                const tdd = link.tddPol.toLowerCase();
                
                if (tdd.includes('odd')) {
                    color = '#d9534f'; 
                } else if (tdd.includes('even')) {
                    color = '#5cb85c'; 
                } else if (tdd.includes('p2p')) {
                    color = '#f0ad4e'; 
                }

                const polyline = L.polyline([[link.latA, link.lonA], [link.latB, link.lonB]], {
                    color: color,
                    weight: 2,
                    opacity: 0.7
                }).addTo(mapLayers.lines); 
                
                const clusterName = link.cluster;
                if (clusterLayers[clusterName]) {
                    polyline.addTo(clusterLayers[clusterName]);
                }
            });

            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [20, 20] }); 
            }
        }

        /**
         * Renderiza as tabelas de links e inventário.
         */
        function renderTables() {
            const linkListBody = document.getElementById('linkListBody');
            const nodeInventoryBody = document.getElementById('nodeInventoryBody');
            
            linkListBody.innerHTML = '';
            nodeInventoryBody.innerHTML = '';

            // Preenche Tabela de Links
            links.forEach(link => {
                const tr = document.createElement('tr');
                tr.className = 'border-b last:border-b-0 hover:bg-gray-50 transition-colors duration-150';
                
                tr.innerHTML = `
                    <td class="py-3 px-4">${link.cluster}</td>
                    <td class="py-3 px-4">${link.cenA}</td>
                    <td class="py-3 px-4">${link.cenB}</td>
                    <td class="py-3 px-4">${link.produtoA}</td>
                    <td class="py-3 px-4">${link.produtoB}</td>
                    <td class="py-3 px-4">${link.polarization}</td>
                    <td class="py-3 px-4">${link.tddPol}</td>
                    <td class="py-3 px-4">${link.txPower}</td>
                    <td class="py-3 px-4">${link.freqA}</td>
                    <td class="py-3 px-4">${link.freqB}</td>
                    <td class="py-3 px-4">${link.txOpMode}</td>
                    <td class="py-3 px-4">${link.rssi}</td>
                    <td class="py-3 px-4">${link.setor1CalculatedAzimuth}</td>
                    <td class="py-3 px-4">${link.sectInDevice}</td>
                    <td class="py-3 px-4">${link.azimuthA}</td>
                    <td class="py-3 px-4">${link.azimuthB}</td>
                `;

                linkListBody.appendChild(tr);
            });

            // Preenche Tabela de Inventário
            const nodesArray = Object.values(nodes);
            
            nodesArray.sort((a, b) => {
                const clusterA = Array.from(a.clusters).join(', ');
                const clusterB = Array.from(b.clusters).join(', ');
                return clusterA.localeCompare(clusterB);
            });

            for (const node of nodesArray) {
                const clusters = Array.from(node.clusters);
                const clustersStr = clusters.length > 0 ? clusters.join('<br>') : '-';
                
                if (node.switchProduct !== '-') {
                    const ip = node.switchIP;
                    const vlan = node.switchVLAN;
                    const serialInfo = serialMap.get(ip) || { serial: '-', partNumber: '-' };

                    const tr = document.createElement('tr');
                    tr.className = 'border-b last:border-b-0 hover:bg-gray-50 transition-colors duration-150';
                    tr.innerHTML = `
                        <td class="py-3 px-4 align-top">${clustersStr}</td>
                        <td class="py-3 px-4 align-top font-semibold">${node.cen}</td>
                        <td class="py-3 px-4 align-top">${node.nodeID}</td>
                        <td class="py-3 px-4 align-top">${node.switchProduct}</td>
                        <td class="py-3 px-4 align-top">${ip}</td>
                        <td class="py-3 px-4 align-top">${vlan}</td>
                        <td class="py-3 px-4 align-top">${serialInfo.partNumber}</td>
                        <td class="py-3 px-4 align-top">${serialInfo.serial}</td>
                    `;
                    nodeInventoryBody.appendChild(tr);
                }

                node.radioProducts.forEach(radio => {
                    const ip = radio.ip;
                    const vlan = radio.vlan;
                    const serialInfo = serialMap.get(ip) || { serial: '-', partNumber: '-' };

                    const tr = document.createElement('tr');
                    tr.className = 'border-b last:border-b-0 hover:bg-gray-50 transition-colors duration-150';
                    tr.innerHTML = `
                        <td class="py-3 px-4 align-top">${clustersStr}</td>
                        <td class="py-3 px-4 align-top font-semibold">${node.cen}</td>
                        <td class="py-3 px-4 align-top">${node.nodeID}</td>
                        <td class="py-3 px-4 align-top">${radio.product}</td>
                        <td class="py-3 px-4 align-top">${ip}</td>
                        <td class="py-3 px-4 align-top">${vlan}</td>
                        <td class="py-3 px-4 align-top">${serialInfo.partNumber}</td>
                        <td class="py-3 px-4 align-top">${serialInfo.serial}</td>
                    `;
                    nodeInventoryBody.appendChild(tr);
                });
            }
        }

        /**
         * Limpa o mapa e as tabelas antes de um novo carregamento.
         */
        function clearVisuals() {
            if (mapLayers.markers) mapLayers.markers.clearLayers();
            if (mapLayers.lines) mapLayers.lines.clearLayers();
            if (mapLayers.sectors1) mapLayers.sectors1.clearLayers();
            if (mapLayers.sectors2) mapLayers.sectors2.clearLayers();
            if (mapLayers.sectors3) mapLayers.sectors3.clearLayers();
            if (mapLayers.sectors4) mapLayers.sectors4.clearLayers();
            
            if (layerControl) {
                for (const clusterName in clusterLayers) {
                    layerControl.removeLayer(clusterLayers[clusterName]); 
                    clusterLayers[clusterName].clearLayers(); 
                }
            }
            clusterLayers = {}; 

            document.getElementById('linkListBody').innerHTML = '';
            document.getElementById('nodeInventoryBody').innerHTML = '';
            
            document.getElementById('tablesContainer').classList.add('hidden');
            // ====================================================================
            // 4. ESCONDER BOTÃO DE EXPORTAR
            // ====================================================================
            document.getElementById('exportButtonContainer').classList.add('hidden');
        }

        /**
         * Exibe uma mensagem de status ou erro.
         */
        function showMessage(message, isError = false) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            messageBox.className = 'mt-4 p-3 rounded-md text-sm text-center'; 
            
            if (isError) {
                messageBox.classList.add('bg-red-100', 'text-red-700');
            } else {
                messageBox.classList.add('bg-blue-100', 'text-blue-700');
            }
            
            messageBox.classList.remove('hidden');
        }

        /**
         * Controla a lógica de troca de abas.
         */
        function openTab(event, tabID) {
            const tabContents = document.getElementsByClassName('tab-content');
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove('active');
            }
            
            const tabButtons = document.getElementsByClassName('tab-button');
            for (let i = 0; i < tabButtons.length; i++) {
                tabButtons[i].classList.remove('active');
            }
            
            document.getElementById(tabID).classList.add('active');
            event.currentTarget.classList.add('active');
        }


        // ====================================================================
        // 3. NOVA FUNÇÃO DE EXPORTAÇÃO
        // ====================================================================
        /**
         * Exporta os dados combinados de links e inventário para um arquivo CSV.
         */
        function exportToCSV() {
            if (links.length === 0) {
                showMessage("Não há dados para exportar. Gere a topologia primeiro.", true);
                return;
            }

            // Função helper para formatar valores para CSV (trata ';' e '"')
            const quote = (val) => {
                const str = (val === null || val === undefined) ? '-' : val.toString();
                // Se o valor contém aspas, ponto-e-vírgula ou quebra de linha, envolve com aspas
                if (str.includes('"') || str.includes(';') || str.includes('\n')) {
                    return `"${str.replace(/"/g, '""')}"`;
                }
                return str;
            };

            // Define o cabeçalho do CSV
            const headers = [
                // Dados do Link (da tabela Lista de Links)
                "Cluster", "CEN A", "CEN B", "Produto A", "Produto B", "Polarization",
                "TDD-POL", "TX Power A/B (dBm)", "Freq. A (MHz)", "Freq. B (MHz)",
                "TX op-mode A/B", "RSSI (dBm) A/B", "Setor 1 (Azimute)",
                "Sect-In-Device", "Azimute A (deg)", "Azimute B (deg)",
                
                // Dados associados (Inventário)
                "Node ID A", "IP Rádio A", "PN Rádio A", "SN Rádio A",
                "Node ID B", "IP Rádio B", "PN Rádio B", "SN Rádio B",
                
                "Switch Produto (Node A)", "Switch IP (Node A)", "Switch VLAN (Node A)",
                "Switch PN (Node A)", "Switch SN (Node A)",
                
                "Switch Produto (Node B)", "Switch IP (Node B)", "Switch VLAN (Node B)",
                "Switch PN (Node B)", "Switch SN (Node B)"
            ];

            let csvContent = headers.join(';') + '\n';

            // Processa cada linha de link
            links.forEach(link => {
                // Pega os dados dos nós (inventário)
                const nodeA = nodes[link.idA] || {};
                const nodeB = nodes[link.idB] || {};
                
                // Pega seriais dos Rádios (usando os IPs do link)
                const serialRadioA = serialMap.get(link.ipA) || { serial: '-', partNumber: '-' };
                const serialRadioB = serialMap.get(link.ipB) || { serial: '-', partNumber: '-' };
                
                // Pega seriais dos Switches (usando os IPs dos nós)
                const serialSwitchA = serialMap.get(nodeA.switchIP) || { serial: '-', partNumber: '-' };
                const serialSwitchB = serialMap.get(nodeB.switchIP) || { serial: '-', partNumber: '-' };

                // Monta a linha de dados
                const row = [
                    // Dados do Link
                    link.cluster, link.cenA, link.cenB, link.produtoA, link.produtoB,
                    link.polarization, link.tddPol, link.txPower, link.freqA, link.freqB,
                    link.txOpMode, link.rssi, link.setor1CalculatedAzimuth,
                    link.sectInDevice, link.azimuthA, link.azimuthB,
                    
                    // Dados Rádio A
                    link.idA, link.ipA, serialRadioA.partNumber, serialRadioA.serial,
                    
                    // Dados Rádio B
                    link.idB, link.ipB, serialRadioB.partNumber, serialRadioB.serial,

                    // Dados Switch Node A
                    nodeA.switchProduct, nodeA.switchIP, nodeA.switchVLAN,
                    serialSwitchA.partNumber, serialSwitchA.serial,
                    
                    // Dados Switch Node B
                    nodeB.switchProduct, nodeB.switchIP, nodeB.switchVLAN,
                    serialSwitchB.partNumber, serialSwitchB.serial
                ];

                csvContent += row.map(quote).join(';') + '\n';
            });

            // Cria e baixa o arquivo
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.setAttribute("href", url);
            a.setAttribute("download", "Topologia_Completa_SmartRIO.csv");
            a.style.visibility = "hidden";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        // ====================================================================


        // --- Event Listeners ---
        document.getElementById('generateButton').addEventListener('click', handleFiles);
        window.addEventListener('load', initMap);
        
        // ====================================================================
        // 4. CONECTAR O BOTÃO DE EXPORTAR
        // ====================================================================
        document.getElementById('exportButton').addEventListener('click', exportToCSV);

    </script>
</body>
</html>